---
stage: 1
status: done
---
По умолчанию аргументы в C# передаются по значению. Это значит, что для значимых типов создаётся *копия переменной*, которая попадает в метод, а для ссылочных типов создаётся *копия ссылки*. Модификаторы аргументов позволяют менять это поведение.

При передаче значения значимых типов метод получает копию переменной, а значит он не имеет доступа к оригинальному значению и могжет менять только локальную копию.

При передаче значения ссылочных типов метод получает копию ссылки, которая указывает на тот же объект. Внутри метода можно менять оригинальный объект и эти изменения отразятся снаружи, но если перезаписать локальную ссылку, объект изменится только локально.

С помощью модификатора `ref` можно передавать аргументы в метод по ссылке. В таком случае метод сможет изменять оригинальный объект значимого типа и перезаписывать оригинальный объект ссылочного типа.

# контекст безопасности ссылок и значений

Методы могут записывать значения параметров в поля. Когда параметры передаются по значению это достаточно безопасно. Значения копируются, а ссылки на объекты ссылочныъ типов остаются доступными, пока находятся в поле. Передача параметров по ссылке требует от компилятора проверить, будет ли безопасно назначить ссылку в новую переменную. Для каждого выражения компилятор определяет *безопасный контекст*, который ограничивает доступ к выражению или переменной. Компилятор использует две области: safe-context и ref-safe-context.

- safe-context определяет область, в которой к любому выражению можно безопасно получить доступ
- ref-safe-context определяет область, в которой к *ссылке* на любое выражение можно безопасно получить доступ и изменить её

Можно считать, что это способ убедиться, что код никогда не получит доступ или не попытается изменить ссылку, которой больше не существует. Ссылка существует, пока существует объект, на который она ссылается.

# ссылочные параметры

Можно применить один из следующих модификаторов при объявлении параметров:

- `ref` - Аргумент должен быть инициализирован перед передачей в метод. Метод может присвоить новое значение аргументу, но не обязан. Требуется точное совпадение типов. Аргумент для `ref` параметра должен содержать модификатор `ref`.
- `out` - Вызывающая сторона не обязана инициализировать аргумент перед передачей в метод. Метод обязан записать значение в параметр. Аргумент для `out` параметра должен содержать модификатор `out`.
- `ref readonly` - Аргумент должен быть инициализирован перед вызовом метода. Метод не может присвоить новое значение аргументу (генерирует ошибку компиляции), но может изменить оригинальный объект. *Доступен с C# 12*. Аргумент для `ref readonly` параметра должен содержать модификатор `ref` или `in`, но не оба. Если ни один из модификаторов не указан, создаётся предупреждение.
- `in` - Аргумент должен быть инициализирован перед вызовом метода. Метод не может присвоить новое значение в параметр. Компилятор может создать временную переменную (при необходимости конвертирования типов) для хранения копии аргумента и передать методу readonly ссылку на эту переменную. Аргумент для `in` параметра может опционально содержать модификатор `in`. Если указан `ref`, создаётся предупреждение.

Члены класса не могут отличаться только наличием `ref`, `ref readonly`, `in`, `out`, это приводит к ошибке компиляции. Но можно иметь перегрузки, одна из которых работает со значением, а другая со ссылкой. В других ситуациях, которые требуют проверки сигнатуры (переопределение или скрытие), `ref`, `ref readonly`, `in`, `out` считаются её частью и не соответствуют друг другу.

Эти модификаторы не могут быть использованы в следующих случаях:

- В асинхронных методах, обозначаемых модификатором `async`.
- В методах итераторах, использующих `yield return` или `yield break`.

Методы расширения так же накладывают свои ограничения:

- Ключевое слово `out` не может быть использовано на первом аргументе метода.
- Ключевое слово `ref` не может быть использовано на первом аргументе метода когда аргумент не [[struct]] или [Generic тип](Generic%20классы) не ограничен быть структурой.
- Ключевые слова `ref readonly` и `in` не могут быть использованы на первом аргументе метода когда аргумент не [[struct]].
- Ключевые слова `ref readonly` и `in` не могут быть использованы в любом generic типе, даже если он ограничен на struct.

Свойства - не переменные, а методы, поэтому они не могут быть аргументами для `ref` параметров.

# модификатор params

Параметр с модификатором `params` должен быть последним и только один. Тип параметра с модификатором params должен быть коллекцией. Поддерживаемые типы коллекций:

- Массив с одним измерением `T[]`
- Span
	- `System.Span<T>`
	- `System.ReadOnlySpan<T>`
- Тип с доступным методом [Create](Выражения%20коллекций.md#Конструктор%20коллекций).
- Структура или класс, которые реализуют `System.Collections.Generic.IEnumerable<T>`, которые:
	- имеют конструктор по умолчанию, который доступен как минимум так же, как и объявляющий член
	- тип имеет собственный (не расширением) метод `Add`, который
		-  может быть вызван с одним аргументом
		- если метод имеет параметр типа, тип должно быть возможно определить из контекста
		- доступен как минимум так же, как и объявляющий член
- Интерфейс
	- `System.Collections.Generic.IEnumerable<T>`
	- `System.Collections.Generic.IReadOnlyCollection<T>`
	- `System.Collections.Generic.IReadOnlyList<T>`
	- `System.Collections.Generic.ICollection<T>`
	- `System.Collections.Generic.IList<T>`

До C# 13 можно было использовать только массивы с одним измерением

Вызывая метод с параметром `params` можно передать:

- Список аргументов типа элемента коллекции, разделённый запятой
- Коллекцию элементов указанного типа
- Ничего. В этом случае длина коллекции `params` будет 0.