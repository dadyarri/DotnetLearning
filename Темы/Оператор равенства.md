---
tags:
  - этап1
  - done
---
Операторы равенства `==` и `!=` проверяют, равны ли операнды. Значимые типы равны, когда равно их значение. Ссылочные типы (кроме [[record]]) равны, когда две переменные указывают на то же хранилище.

Можно использовать оператор `is`, как альтернативу `==` при сравнивании с [константным значением](Pattern%20Matching#Константный).

Если ссылочный тип переопределяет оператор `==`, можно использовать `Object.ReferenceEquals`, чтобы проверить, что две ссылки указывают на один объект.

`record`ы по умолчанию равны, если оба объекта равны `null` или соответствующие значения всех полей и автоматически реализованных свойств равны.

Два операнда типа `string` равны когда обе `null` или когда обе имеют одинаковую длину и одинаковые символы в каждой позиции (регистро-зависимо).

Два [делегата](delegate) одного типа равны, когда оба `null` или их список запуска одинаковой длины и имеет одинаковые записи в каждой из позиций.

Делегаты, созданные из семантически одинаковых лямбда-выражений не равны:

```cs
Action a = () => Console.WriteLine("a");
Action b = () => Console.WriteLine("a");

Console.WriteLine(a == b);  // output: False
Console.WriteLine(a + b == a + b);  // output: True
Console.WriteLine(b + a == a + b);  // output: False
```

Оператор неравенства `a != b` для встроенных типов возвращает то же, что и `!(a == b)`.

Пользовательские типы могут перегрузить операторы `==` и `!=`. Если перегружен один из операторов, должен быть перегружен и второй.

В `record` нельзя явно перегрузить операторы равенства. Если нужно изменить их поведение, нужно реализовать метод `IEquatable<T>.Equals` со следующей сигнатурой:

```cs
public virtual bool Equals(T? other);
```