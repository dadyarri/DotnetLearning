---
tags:
  - этап1
  - done
---
Тип структуры - значимый тип, который может объединять данные и связанный функционал. Чтобы объявить структуру используется ключевое слово `struct`:

```cs
public struct Coords
{
    public Coords(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double X { get; }
    public double Y { get; }

    public override string ToString() => $"({X}, {Y})";
}
```

Тип структуры имеет семантику значимого типа. Так, переменная типа структуры содержит объект типа. По умолчанию значения переменных копируются при присвоении, передаче аргумента в метод и возвращении из метода.

Обычно структуры используются для создания маленьких типов, сфокусированных на данных с минимальным количеством логики или вообще без неё.

Так как структуры имеют семантику value-типа, рекомендуется создавать иммутабельные структуры.

```ad-important
Если структура содержит поле ссылочного типа, при копировании структуры сохранится ссылка на исходный объект ссылочного типа и обе копии структуры будут иметь доступ к одному объекту ссылочного типа.
```

# readonly структуры

Можно использовать модификатор `readonly`, чтобы сделать структуру иммутабельной.

В таком случае все члены readonly структуры автоматически становятся readonly, а автоматически имплементированные могут иметь метод `init` (доступно с C# 9+) но не могут иметь `set`.

Это гарантирует, что ни один член иммутабельной структуры не изменит её состояния.

```ad-note
В `readonly` структуре члены изменяемых ссылочных типов всё ещё могут менять своё состояние. Например, нельзя заменить объект `List<T>`, но можно добавить в него новый элемент.

```

```cs
public readonly struct Coords
{
    public Coords(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double X { get; init; }
    public double Y { get; init; }

    public override string ToString() => $"({X}, {Y})";
}
```

# readonly члены объекта

Можно использовать модификатор `readonly` на отдельных членах, которые не изменяют состояние структуры, в случае, если нельзя применить модификатор `readonly` ко всей структуре.

Внутри `readonly`-члена нельзя присваивать значения полям структуры, но `readonly` член может вызывать не `readonly` члены. В этом случае компилятор создаёт копию структуры и вызывает не `readonly` член на этой копии, не изменяя оригинал.

Компилятор может использовать модификатор `readonly` для оптимизаций производительности, подробнее в [[Избегание аллокаций]].

# недеструктивное изменение

Можно использовать выражение `with` для копирования объекта структуры с изменёнными свойствами и полями. 

```cs
public readonly struct Coords
{
    public Coords(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double X { get; init; }
    public double Y { get; init; }

    public override string ToString() => $"({X}, {Y})";
}

public static void Main()
{
    var p1 = new Coords(0, 0);
    Console.WriteLine(p1);  // output: (0, 0)

    var p2 = p1 with { X = 3 };
    Console.WriteLine(p2);  // output: (3, 0)

    var p3 = p1 with { X = 1, Y = 4 };
    Console.WriteLine(p3);  // output: (1, 4)
}
```

# инициализация структуры и значения по умолчанию

Переменная типа `struct` напрямую содержит данные для этой структуры. Поэтому неинициализированная структура, которая имеет значения по умолчанию отличается от инициализированной, которая хранит значения, создавая объект:

```cs
public readonly struct Measurement
{
    public Measurement()
    {
        Value = double.NaN;
        Description = "Undefined";
    }

    public Measurement(double value, string description)
    {
        Value = value;
        Description = description;
    }

    public double Value { get; init; }
    public string Description { get; init; }

    public override string ToString() => $"{Value} ({Description})";
}

public static void Main()
{
    var m1 = new Measurement();
    Console.WriteLine(m1);  // output: NaN (Undefined)

    var m2 = default(Measurement);
    Console.WriteLine(m2);  // output: 0 ()

    var ms = new Measurement[2];
    Console.WriteLine(string.Join(", ", ms));  // output: 0 (), 0 ()
}
```

Как видно, выражение `default` и механизм создания массива игнорируют конструктор без параметров и создаёт структуру с значениями по умолчанию.

# ограничения дизайна структур

У структур есть большинство возможностей классов, но с некоторыми ограничениями:

- Структура не может наследовать классы или структуры и не может быть базовой для класса. Но структура может реализовывать интерфейсы.
- Нельзя объявить финализатор структуры.
- До C# 11 конструктор структуры должен был объявить все поля типа.

# передача структур по ссылке

Когда переменная типа структуры передаётся в метод или возвращается из метода, весь объект копируется. Передача по значению может повлиять на производительность в высокопроизводительных сценариях работы с большими структурами. Можно избежать копирования, передавая структуры по ссылке. Для этого есть модификаторы `ref`, `out`, `in` или `ref readonly`, которые обозначают, что аргумент должен быть передан по ссылке. Используйте `return ref` для возвращения результата по ссылке.

| Ключевое слово | Передаётся / Возвращается                | Чтение? | Запись? | Необходимо записать? | Предназначение                                            |
| -------------- | ---------------------------------------- | ------- | ------- | -------------------- | --------------------------------------------------------- |
| -              | По значению (копируется)                 | ✅       | ✅       | ❌                    | Обычное поведение - вся структура копируется при передаче |
| `ref`          | По ссылке                                | ✅       | ✅       | ❌                    | Прочитать (и возможно изменить) значение вызвавшего       |
| `out`          | По ссылке                                | ❌       | ✅       | ✅                    | Вернуть значение по ссылке через параметр                 |
| `in`           | По ссылке                                | ✅       | ❌       | ❌                    | Передать значение по ссылке, но запретить изменение       |
| `ref readonly` | По ссылке (только возвращаемое значение) | ✅       | ❌       | ❌                    | Вернуть ссылку, но запретить изменение                    |
| `return ref`   | По ссылке                                | ✅       | ✅       | ❌                    | Вернуть ссылку                                            |
# ограничение `struct`

Можно использовать ключевое слово `struct`в выражении ограничения в дженериках, чтобы указать, что тип должен быть non-nullable value type. И структуры и Enum соответствуют этому ограничению