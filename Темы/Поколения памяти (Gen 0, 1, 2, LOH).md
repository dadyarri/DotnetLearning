---
stage: 1
status: done
---
Чтобы улучшить производительность сборщика мусора, управляемая куча разделена на три поколения: 0, 1 и 2. Алгоритм основан на нескольких предположениях:

- Быстрее уплотнять память для фрагмента управляемой кучи, чем для всей управляемой кучи
- Более новые объекты живут меньше, более старые - дольше
- Более новые объекты обычно связаны и используются приблизительно одно время

Сборщик мусора помещает новые объекты в поколение 0. Объекты, которые были созданы раньше и пережили сборку мусора перемещаются в поколения 1 и 2. Это позволяет высвобождать память только в одном поколении, а не во всех сразу каждый раз при запуске сборки.

В реальности сборка мусора запускается, когда переполняется 0 поколение. Если приложение в это время пытается создать новый объект, сборщик мусора понимает, что свободного пространства не осталось, запускается сборка с целью освободить место под новый объект, проверяя объекты в поколении 0. Это самый оптимальный способ, т. к. новые объекты обычно имеют короткое время жизни и ожидается, что многие объекты в поколении 0 будут не нужны к моменту, как понадобится сборка. Кроме того, очистки одного только поколения 0 обычно достаточно, чтобы приложение продолжило создавать новые объекты.

После завершения сборки поколения 0, сборщик уплотняет занятую память и "повышает" оставшиеся объекты в поколение 1, так как выжившие объекты обычно имеют более длительное время жизни и так сборщику не придётся снова проверять эти объекты каждый раз при сборке поколения 0.

Если очистка поколения 0 не освободила достаточно памяти для нового объекта, начинается очистка поколения 1, если очистки поколения 1 не хватило, запускается очистка поколения 2. Объекты в поколении 2 остаются в памяти до тех пор, пока они не начнут считаться доступными для сборки.

# Large Object Heap

Если объект больше 85000 байт, он считается большим (large) объектом и рантайм размещает его на LOH.

Когда стартует процесс, сборщик мусора инициализирует память под два сегмента кучи: для маленьких объектов (Small Object Heap, SOH) и для больших (LOH). 

Если памяти для создания большого объекта недостаточно, GC пытается сначала запросить больше памяти у ОС, при провале - запускается сборка 2 поколения.

LOH собирается только во время сборки 2 поколения

