---
stage: 2
status: todo
---
По сути это хеш таблица:
- `_buckets: int[]` - Массив, где индекс - это номер корзины (рассчитанный на основе хеш-кода ключа), а значение - это **1-based индекс** (то есть индекс + 1) в массиве `_entries`, указывающий на первую запись в цепочке для этой корзины. Значение `0` означает пустую корзину.
- `_entries: Entry[]` - где хранятся все данные (в т. ч. удалённые)
- `_freeList: int` - индекс в `_entries`, с которого начинаются удалённые записи
- `_freeCount: int` - количество удалённых записей
- `_count: int` - общее количество записей, включая удалённые

# Процесс добавления записи

1. Вычисление хеш-кода через `comparer.GetHashCode(TKey)`
2. Операцией модуля вычисляется индекс бакета, в который будет отправлен элемент
3. Затем в бакете производится поиск ключа (сначала по хеш-кодам, затем точно по ключу)
4. Разрешение коллизий
	1. Если ключ найден, поведение зависит от `InsertionBehavior` (перезаписать или выбросить исключение)
	2. Если ключ не найден, элемент добавляется в цепочку
5. Добавление записей
	1. Сначала проверяется `_freeList`. Если есть удалённые записи, первая из них переиспользуется
	2. Если удалённых записей нет, элемент добавляется в конец массива `_entries`
	3. Новый элемент становится головой цепочки, а в `_buckets` записывается индекс нового элемента

# Вероятные вопросы

`Dictionary<TKey, TValue>` не гарантирует порядок записей (в целом, если не удалять записи, он сохраняется, но при добавлении записей после удаления или ресайзе внутренних массивов порядок может меняться)

Сложность операций `Add`, `Remove`, `ContainsKey`, `TryGetValue`: **O(1)** в среднем случае (когда хеш-коды распределены равномерно), **O(n)** - в худшем (при большом количестве коллизий, например, если хеш-функция реализована плохо).

Если место в массиве `_entries` заканчивается, создаются новые массивы `_buckets` и `_entries` размером следующего простого числа, перехешируются и заново распределяются по бакетам все существующие записи (операция **O(n)**).

Для ключей - [значимого типа](Value%20типы), по умолчанию используется компаратор `EqualityComparer<TKey>.Default`, для строк по умолчанию используется `NonRandomizedStringEqualityComparer`, который вычисляет хеш строки, не полагаясь на случайный seed, но при большом количестве коллизий автоматически переключается на рандомизированную версию `EqualityComparer<string>.Default` и выполняет полное перехеширование.

`Dictionary<TKey, TValue>` не потокобезопасен. Одновременная запись из нескольких потоков может привести к ошибкам и повреждению внутренних данных. Вместо этого лучше использовать `ConcurrentDictionary<TKey, TValue>`.

Если во время перечисления словаря в цикле `foreach` попытаться его изменить будет выброшена исключение `InvalidOperationException`. 

При использовании кастомных ссылочных типов в качестве ключа нельзя их изменять на протяжении всего времени жизни словаря: при изменении ключа изменится его хеш и значение нельзя будет найти, так как поиск будет произодится в неправильном бакете